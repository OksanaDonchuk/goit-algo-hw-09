# goit-algo-hw-09

**Python. HW 9. Greedy algorithms and dynamic programming**

## Опис домашнього завдання

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет `[50, 25, 10, 5, 2, 1]`. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

- **Функція жадібного алгоритму** `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми `113` це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

- **Функція динамічного програмування** `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми `113` це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях.

## Аналіз

Після проведення розрахунків для набору сум amounts = [56, 98, 113, 560, 982] і вимірювання часу виконання обох алгоритмів, можна зробити наступні висновки:

1. **Жадібний алгоритм** `(find_coins_greedy)`:

✔️ Складність: `O(n)`, де `n` — кількість номіналів монет. Оскільки `n` у нашому випадку є сталим (6 монет), алгоритм виконується дуже швидко.

✔️ Продуктивність: Працює блискавично навіть для великих значень суми `(982)`, оскільки перебирає номінали тільки один раз і не використовує додаткової пам'яті.

✔️ Оптимальність: Завжди знаходить мінімальну кількість монет за умови, що найбільші монети кратні меншим (як у нашому випадку: `50, 25, 10, 5, 2, 1`).

2. **Алгоритм динамічного програмування** `(find_min_coins)`:

✔️ Складність: `O(m * n)`, де `m` — сума для розбиття, а `n` — кількість номіналів. Це означає, що час виконання збільшується зі зростанням суми.

✔️ Продуктивність: Для малих значень суми алгоритм працює прийнятно, але для `982` помітно повільніший, оскільки потрібно обчислювати всі можливі варіанти розбиття суми.

✔️ Оптимальність: Завжди знаходить абсолютно мінімальну кількість монет, навіть якщо набір номіналів не підходить для жадібного алгоритму (наприклад, для монет `{9, 6, 1}`, де жадібний алгоритм не дає оптимального рішення).

## Висновки:

**Жадібний алгоритм** значно ефективніший за швидкістю і споживанням пам'яті, підходить для касових систем, оскільки дає правильний результат швидко.

**Алгоритм динамічного програмування** є гарантовано оптимальним у всіх випадках, але може працювати повільніше при великих сумах.

Якщо набір монет добре впорядкований (кожен номінал кратний меншим), жадібний алгоритм працює ідеально. Але при складних наборах номіналів потрібно використовувати динамічне програмування.

Для касових апаратів та банківських систем варто використовувати жадібний алгоритм. Якщо ж номінали нестандартні, або потрібно гарантувати мінімальну кількість монет, краще використовувати динамічне програмування.
